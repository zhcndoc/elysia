import"./marked.esm.Be0tUUzX.js";import"./dayjs.min.2LOTCKlH.js";import{a as e}from"./flatten.CgWqSnCR.js";import{g as t,h as n}from"./src.C0f_AavH.js";import{b as r}from"./chunk-ABZYJK2D.CLCQEh99.js";import"./chunk-S3R3BYOJ.BGUS-zLY.js";import"./dist.fUoWkJal.js";import"./chunk-JA3XYJ7Z.BtsDX1b_.js";import"./chunk-HN2XXSSU.n-h83BuS.js";import{t as i}from"./chunk-CVBHYZKI.BloYA-CQ.js";import{n as a,t as o}from"./graphlib.oJqe4G6e.js";import{t as s}from"./clone.Ba_r98AL.js";import{t as c}from"./dagre.DfalR6mG.js";import"./chunk-ATLVNIR6.Ccb6MwLb.js";import{a as l,c as u,i as d,l as f,n as p,t as m,u as h}from"./chunk-JZLCHNYA.CoaqoegJ.js";import{a as g,i as _,n as v,r as y,t as b}from"./chunk-QXUST7PY.BvZPZn_b.js";function x(e){var t={options:{directed:e.isDirected(),multigraph:e.isMultigraph(),compound:e.isCompound()},nodes:S(e),edges:C(e)};return a(e.graph())||(t.value=s(e.graph())),t}function S(t){return e(t.nodes(),function(e){var n=t.node(e),r=t.parent(e),i={v:e};return a(n)||(i.value=n),a(r)||(i.parent=r),i})}function C(t){return e(t.edges(),function(e){var n=t.edge(e),r={v:e.v,w:e.w};return a(e.name)||(r.name=e.name),a(n)||(r.value=n),r})}var w=new Map,T=new Map,E=new Map,D=n(()=>{T.clear(),E.clear(),w.clear()},`clear`),O=n((e,n)=>{let r=T.get(n)||[];return t.trace(`In isDescendant`,n,` `,e,` = `,r.includes(e)),r.includes(e)},`isDescendant`),k=n((e,n)=>{let r=T.get(n)||[];return t.info(`Descendants of `,n,` is `,r),t.info(`Edge is `,e),e.v===n||e.w===n?!1:r?r.includes(e.v)||O(e.v,n)||O(e.w,n)||r.includes(e.w):(t.debug(`Tilt, `,n,`,not in descendants`),!1)},`edgeInCluster`),A=n((e,n,r,i)=>{t.warn(`Copying children of `,e,`root`,i,`data`,n.node(e),i);let a=n.children(e)||[];e!==i&&a.push(e),t.warn(`Copying (nodes) clusterId`,e,`nodes`,a),a.forEach(a=>{if(n.children(a).length>0)A(a,n,r,i);else{let o=n.node(a);t.info(`cp `,a,` to `,i,` with parent `,e),r.setNode(a,o),i!==n.parent(a)&&(t.warn(`Setting parent`,a,n.parent(a)),r.setParent(a,n.parent(a))),e!==i&&a!==e?(t.debug(`Setting parent`,a,e),r.setParent(a,e)):(t.info(`In copy `,e,`root`,i,`data`,n.node(e),i),t.debug(`Not Setting parent for node=`,a,`cluster!==rootId`,e!==i,`node!==clusterId`,a!==e));let s=n.edges(a);t.debug(`Copying Edges`,s),s.forEach(a=>{t.info(`Edge`,a);let o=n.edge(a.v,a.w,a.name);t.info(`Edge data`,o,i);try{k(a,i)?(t.info(`Copying as `,a.v,a.w,o,a.name),r.setEdge(a.v,a.w,o,a.name),t.info(`newGraph edges `,r.edges(),r.edge(r.edges()[0]))):t.info(`Skipping copy of edge `,a.v,`-->`,a.w,` rootId: `,i,` clusterId:`,e)}catch(e){t.error(e)}})}t.debug(`Removing node`,a),n.removeNode(a)})},`copy`),j=n((e,t)=>{let n=t.children(e),r=[...n];for(let i of n)E.set(i,e),r=[...r,...j(i,t)];return r},`extractDescendants`),M=n((e,t,n)=>{let r=e.edges().filter(e=>e.v===t||e.w===t),i=e.edges().filter(e=>e.v===n||e.w===n),a=r.map(e=>({v:e.v===t?n:e.v,w:e.w===t?t:e.w})),o=i.map(e=>({v:e.v,w:e.w}));return a.filter(e=>o.some(t=>e.v===t.v&&e.w===t.w))},`findCommonEdges`),N=n((e,n,r)=>{let i=n.children(e);if(t.trace(`Searching children of id `,e,i),i.length<1)return e;let a;for(let e of i){let t=N(e,n,r),i=M(n,r,t);if(t)if(i.length>0)a=t;else return t}return a},`findNonClusterChild`),P=n(e=>!w.has(e)||!w.get(e).externalConnections?e:w.has(e)?w.get(e).id:e,`getAnchorId`),F=n((e,n)=>{if(!e||n>10){t.debug(`Opting out, no graph `);return}else t.debug(`Opting in, graph `);e.nodes().forEach(function(n){e.children(n).length>0&&(t.warn(`Cluster identified`,n,` Replacement id in edges: `,N(n,e,n)),T.set(n,j(n,e)),w.set(n,{id:N(n,e,n),clusterData:e.node(n)}))}),e.nodes().forEach(function(n){let r=e.children(n),i=e.edges();r.length>0?(t.debug(`Cluster identified`,n,T),i.forEach(e=>{O(e.v,n)^O(e.w,n)&&(t.warn(`Edge: `,e,` leaves cluster `,n),t.warn(`Descendants of XXX `,n,`: `,T.get(n)),w.get(n).externalConnections=!0)})):t.debug(`Not a cluster `,n,T)});for(let t of w.keys()){let n=w.get(t).id,r=e.parent(n);r!==t&&w.has(r)&&!w.get(r).externalConnections&&(w.get(t).id=r)}e.edges().forEach(function(n){let r=e.edge(n);t.warn(`Edge `+n.v+` -> `+n.w+`: `+JSON.stringify(n)),t.warn(`Edge `+n.v+` -> `+n.w+`: `+JSON.stringify(e.edge(n)));let i=n.v,a=n.w;if(t.warn(`Fix XXX`,w,`ids:`,n.v,n.w,`Translating: `,w.get(n.v),` --- `,w.get(n.w)),w.get(n.v)||w.get(n.w)){if(t.warn(`Fixing and trying - removing XXX`,n.v,n.w,n.name),i=P(n.v),a=P(n.w),e.removeEdge(n.v,n.w,n.name),i!==n.v){let t=e.parent(i);w.get(t).externalConnections=!0,r.fromCluster=n.v}if(a!==n.w){let t=e.parent(a);w.get(t).externalConnections=!0,r.toCluster=n.w}t.warn(`Fix Replacing with XXX`,i,a,n.name),e.setEdge(i,a,r,n.name)}}),t.warn(`Adjusted Graph`,x(e)),I(e,0),t.trace(w)},`adjustClustersAndEdges`),I=n((e,n)=>{if(t.warn(`extractor - `,n,x(e),e.children(`D`)),n>10){t.error(`Bailing out`);return}let r=e.nodes(),i=!1;for(let t of r){let n=e.children(t);i||=n.length>0}if(!i){t.debug(`Done, no node has children`,e.nodes());return}t.debug(`Nodes = `,r,n);for(let i of r)if(t.debug(`Extracting node`,i,w,w.has(i)&&!w.get(i).externalConnections,!e.parent(i),e.node(i),e.children(`D`),` Depth `,n),!w.has(i))t.debug(`Not a cluster`,i,n);else if(!w.get(i).externalConnections&&e.children(i)&&e.children(i).length>0){t.warn(`Cluster without external connections, without a parent and with children`,i,n);let r=e.graph().rankdir===`TB`?`LR`:`TB`;w.get(i)?.clusterData?.dir&&(r=w.get(i).clusterData.dir,t.warn(`Fixing dir`,w.get(i).clusterData.dir,r));let a=new o({multigraph:!0,compound:!0}).setGraph({rankdir:r,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});t.warn(`Old graph before copy`,x(e)),A(i,e,a,i),e.setNode(i,{clusterNode:!0,id:i,clusterData:w.get(i).clusterData,label:w.get(i).label,graph:a}),t.warn(`New graph after copy node: (`,i,`)`,x(a)),t.debug(`Old graph after copy`,x(e))}else t.warn(`Cluster ** `,i,` **not meeting the criteria !externalConnections:`,!w.get(i).externalConnections,` no parent: `,!e.parent(i),` children `,e.children(i)&&e.children(i).length>0,e.children(`D`),n),t.debug(w);r=e.nodes(),t.warn(`New list of nodes`,r);for(let i of r){let r=e.node(i);t.warn(` Now next level`,i,r),r?.clusterNode&&I(r.graph,n+1)}},`extractor`),L=n((e,t)=>{if(t.length===0)return[];let n=Object.assign([],t);return t.forEach(t=>{let r=L(e,e.children(t));n=[...n,...r]}),n},`sorter`),R=n(e=>L(e,e.children()),`sortNodesByHierarchy`),z=n(async(e,r,a,o,s,p)=>{t.warn(`Graph in recursive render:XAX`,x(r),s);let m=r.graph().rankdir;t.trace(`Dir in recursive render - dir:`,m);let _=e.insert(`g`).attr(`class`,`root`);r.nodes()?t.info(`Recursive render XXX`,r.nodes()):t.info(`No nodes found for`,r),r.edges().length>0&&t.info(`Recursive edges`,r.edge(r.edges()[0]));let b=_.insert(`g`).attr(`class`,`clusters`),S=_.insert(`g`).attr(`class`,`edgePaths`),C=_.insert(`g`).attr(`class`,`edgeLabels`),T=_.insert(`g`).attr(`class`,`nodes`);await Promise.all(r.nodes().map(async function(e){let n=r.node(e);if(s!==void 0){let n=JSON.parse(JSON.stringify(s.clusterData));t.trace(`Setting data for parent cluster XXX
 Node.id = `,e,`
 data=`,n.height,`
Parent cluster`,s.height),r.setNode(s.id,n),r.parent(e)||(t.trace(`Setting parent`,e,s.id),r.setParent(e,s.id,n))}if(t.info(`(Insert) Node XXX`+e+`: `+JSON.stringify(r.node(e))),n?.clusterNode){t.info(`Cluster identified XBX`,e,n.width,r.node(e));let{ranksep:i,nodesep:s}=r.graph();n.graph.setGraph({...n.graph.graph(),ranksep:i+25,nodesep:s});let c=await z(T,n.graph,a,o,r.node(e),p),l=c.elem;h(n,l),n.diff=c.diff||0,t.info(`New compound node after recursive render XAX`,e,`width`,n.width,`height`,n.height),f(l,n)}else r.children(e).length>0?(t.trace(`Cluster - the non recursive path XBX`,e,n.id,n,n.width,`Graph:`,r),t.trace(N(n.id,r)),w.set(n.id,{id:N(n.id,r),node:n})):(t.trace(`Node - the non recursive path XAX`,e,T,r.node(e),m),await l(T,r.node(e),{config:p,dir:m}))})),await n(async()=>{let e=r.edges().map(async function(e){let n=r.edge(e.v,e.w,e.name);t.info(`Edge `+e.v+` -> `+e.w+`: `+JSON.stringify(e)),t.info(`Edge `+e.v+` -> `+e.w+`: `,e,` `,JSON.stringify(r.edge(e))),t.info(`Fix`,w,`ids:`,e.v,e.w,`Translating: `,w.get(e.v),w.get(e.w)),await y(C,n)});await Promise.all(e)},`processEdges`)(),t.info(`Graph before layout:`,JSON.stringify(x(r))),t.info(`############################################# XXX`),t.info(`###                Layout                 ### XXX`),t.info(`############################################# XXX`),c(r),t.info(`Graph after layout:`,JSON.stringify(x(r)));let E=0,{subGraphTitleTotalMargin:D}=i(p);return await Promise.all(R(r).map(async function(e){let n=r.node(e);if(t.info(`Position XBX => `+e+`: (`+n.x,`,`+n.y,`) width: `,n.width,` height: `,n.height),n?.clusterNode)n.y+=D,t.info(`A tainted cluster node XBX1`,e,n.id,n.width,n.height,n.x,n.y,r.parent(e)),w.get(n.id).node=n,u(n);else if(r.children(e).length>0){t.info(`A pure cluster node XBX1`,e,n.id,n.x,n.y,n.width,n.height,r.parent(e)),n.height+=D,r.node(n.parentId);let i=n?.padding/2||0,a=n?.labelBBox?.height||0,o=a-i||0;t.debug(`OffsetY`,o,`labelHeight`,a,`halfPadding`,i),await d(b,n),w.get(n.id).node=n}else{let e=r.node(n.parentId);n.y+=D/2,t.info(`A regular node XBX1 - using the padding`,n.id,`parent`,n.parentId,n.width,n.height,n.x,n.y,`offsetY`,n.offsetY,`parent`,e,e?.offsetY,n),u(n)}})),r.edges().forEach(function(e){let n=r.edge(e);t.info(`Edge `+e.v+` -> `+e.w+`: `+JSON.stringify(n),n),n.points.forEach(e=>e.y+=D/2),g(n,v(S,n,w,a,r.node(e.v),r.node(e.w),o))}),r.nodes().forEach(function(e){let n=r.node(e);t.info(e,n.type,n.diff),n.isGroup&&(E=n.diff)}),t.warn(`Returning from recursive render XAX`,_,E),{elem:_,diff:E}},`recursiveRender`),B=n(async(e,n)=>{let i=new o({multigraph:!0,compound:!0}).setGraph({rankdir:e.direction,nodesep:e.config?.nodeSpacing||e.config?.flowchart?.nodeSpacing||e.nodeSpacing,ranksep:e.config?.rankSpacing||e.config?.flowchart?.rankSpacing||e.rankSpacing,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}}),a=n.select(`g`);_(a,e.markers,e.type,e.diagramId),p(),b(),m(),D(),e.nodes.forEach(e=>{i.setNode(e.id,{...e}),e.parentId&&i.setParent(e.id,e.parentId)}),t.debug(`Edges:`,e.edges),e.edges.forEach(e=>{if(e.start===e.end){let t=e.start,n=t+`---`+t+`---1`,r=t+`---`+t+`---2`,a=i.node(t);i.setNode(n,{domId:n,id:n,parentId:a.parentId,labelStyle:``,label:``,padding:0,shape:`labelRect`,style:``,width:10,height:10}),i.setParent(n,a.parentId),i.setNode(r,{domId:r,id:r,parentId:a.parentId,labelStyle:``,padding:0,shape:`labelRect`,label:``,style:``,width:10,height:10}),i.setParent(r,a.parentId);let o=structuredClone(e),s=structuredClone(e),c=structuredClone(e);o.label=``,o.arrowTypeEnd=`none`,o.id=t+`-cyclic-special-1`,s.arrowTypeStart=`none`,s.arrowTypeEnd=`none`,s.id=t+`-cyclic-special-mid`,c.label=``,a.isGroup&&(o.fromCluster=t,c.toCluster=t),c.id=t+`-cyclic-special-2`,c.arrowTypeStart=`none`,i.setEdge(t,n,o,t+`-cyclic-special-0`),i.setEdge(n,r,s,t+`-cyclic-special-1`),i.setEdge(r,t,c,t+`-cyc<lic-special-2`)}else i.setEdge(e.start,e.end,{...e},e.id)}),t.warn(`Graph at first:`,JSON.stringify(x(i))),F(i),t.warn(`Graph after XAX:`,JSON.stringify(x(i)));let s=r();await z(a,i,e.type,e.diagramId,void 0,s)},`render`);export{B as render};